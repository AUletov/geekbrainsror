1) Что выведет этот код? Почему перменная @message доступна в методе make_some_voice()

```
class Geek
  def initialize
    @message = "ruby ruby"
  end

  def make_some_voice
    "I like to #{@message}"
  end
end

alex = Geek.new
puts alex.make_some_voice()
```
`Код выведет 'I like to ruby ruby', @message доступна в методе make_some_voice(), изза того что символ @ делает ее переменной экземпляра класса, доступной в любом месте класса (но не за его пределами)`

2) Что этот код напечатает в STDOUT? Поясните.

```
class Computer
  def initialize
    @sound = "beep beep"
  end

  def self.about
    "Sometimes I go #{@sound}"
  end
end

p Computer.about
```
`Код выведет "Sometimes I go ", т.к. метод initialize не был выполнен перед ним и переменная @sound не определена, таким образом about всегда будет выводить это сообщение, т.к. это метод класса и он не доступен для своих экземпляров, переменная @sound не будет определена до момента создания экземпляра`

3) Что этот код напечатает в STDOUT?

```
class Xyz
  def pots
    @nice
  end
end

xyz = Xyz.new
p xyz.pots
```
`Код напечатает nil, т.к. переменной @nice не присвоено никакого значения (ну и собственно нет операций, которые могли бы являться результатом работы метода)`

4) Что этот код напечатает в STDOUT?

```
class Xyz
  def paper
    unassigned_local_variable
  end
end

xyz = Xyz.new
p xyz.paper
```
`Ошибку, т.к. локальной переменной unassigned_local_variable не присвоено никакого значения, теперь я немного озадачен, почему для переменной экземпляра класса это ошибки не вызывает...`

5) Что этот код напечатает в STDOUT? Поясните что произойдет метод meaning_of_life() вызвать несколько раз для одного объекта.

```
class Something
  def meaning_of_life
    @result ||= result
    "The meaning of life is the number #{@result}"
  end

  def result
    Math.log10(100) * 42 - 48 - 13
  end
end

something = Something.new
p something.meaning_of_life
```
`Код напечатает "The meaning of life is the number 23.0", если вызвать несколько раз для одного объекта, код выведет точно такую же строчку несколько раз, т.к. выражение '@result ||= result' будет присваивать @result значение только в случае если @result nil или false, а так же из за того что метод result все время выдает одно и то же значение (кстати почему то не 42)`

6) Что этот код напечатает в STDOUT? Поясните.

```
class Cup
  PURPOSE = "hold liquids"
  def main_use
    PURPOSE
  end
end

tea_cup = Cup.new
p tea_cup.main_use
```
`Код печатает "hold liquids", т.к. в методе main_use возвращается константа PURPOSE, которая эквивалентна строчке "hold liquids"`

7) Что этот код напечатает в STDOUT? Поясните.

```
class Chair
  AGE = "been around the block"
  def self.about
    "I'm old and I've #{AGE}"
  end
end

p Chair.about
```
`Код печатает "I'm old and I've been around the block", код спокойно выполнит метод класса, а т.к. в нем используется константа а не переменная строчка будет выведена полностью`

8) Что этот код напечатает в STDOUT? Поясните.

```
BEST_MOVIE = "Viking"
BEST_MOVIE = "Matilda"
p BEST_MOVIE
```
`Код выведе "Matilda", однако предупредит о переопределении константы`

9) Что этот код напечатает в STDOUT? Поясните.

```
class Bottle
  DRANK = "lemme hit that"
end

p Bottle::DRANK
```
`Код напечатает "lemme hit that", т.к. Bottle::DRANK это обращение к константе класса`

10) Поясните следующее утвреждение: "В руби все есть объект, так что нет не"
Explain the following statement: "Все в Ruby является объектом, так что нет никаких автономных функций в Ruby, все функции на самом деле методы".

`Методы это функции связанные с каким то объектом. В Руби все является объектом, поэтому в Руби нет автономных функций
Methods are functions that are associated with a specific object. Everything is an object in Ruby, including all instances of classes and classes themselves, so there cannot be any standalone functions, and all functions are methods.
-_-`

11) Поясните почему метод Pig#main_desire может обращаться к методу weight() без префикс self.

```
class Pig
  def weight()
    "100 kg"
  end

  def main_desire()
    "eat all day and be more than #{weight()}"
  end
end

piggy = Pig.new()
piggy.main_desire()
```
`Потому что они оба методы одного экземпляра класса и когда self не указан явно используется скрытый self которым является объект вызвавший изначальный метод т.е. piggy`

12) Поясните вызовв метода через Fan.about и почему декларация метода about() использует зарезервированное слово self.

```
class Fan
  def self.about
    "my job is to keep people cool"
  end
end

p Fan.about
```
`Слово self используется для объявления метода класса`

13) Что этот код напечатает в STDOUT? Поясните.

```
class Woman
  SELF = self
end

p Woman::SELF
```
`'Woman', значение константы SELF, которая в свою очередь равна ключевому слову self, которое в свою очередь в данном случае содержит класс 'Woman'`

14) Что этот код напечатает в STDOUT? Поясните.
```
class Dude
end

def Dude.motto
  "Cowabunga"
end

p Dude.motto
```
`Код печатает "Cowabunga", т.к. вызывается методе motto класса Dude, который объявлен вне самого класса`

15) Что этот код напечатает в STDOUT? Поясните.

```
class Phone
  def Phone.job
    "Distract you from life"
  end
end

p Phone.job
```
`"Distract you from life", т.к. метод объявляется внутри класса запись Phone.job эквивалентна записи self.job`

16) Что этот код напечатает в STDOUT? Поясните.

```
def blah
  "blah blah"
end

class Geek
  def make_some_voice
    "I am #{blah}"
  end
end

p Geek.new.make_some_voice
```
`"I am blah blah", т.к. blah глобальный метод`

17) Укажите кто тут объект, кто сообщение, что метод и кто получатель сообщения:

```
x = 5.to_f
```
`5 - объект, to_f сообщение передаваемое объекту 5, to_f метод, 5 - получатель сообщение`

18) Поясните как сообщение (значение) отправляется, кто тут получатель (метод), и каково содержание сообщения.

```
"table".upcase()
```
`Сообщение upcase отправляется объекту "table" в сообщении находится upcase и при получении его "table" выполняет метод upcase`

19) Укажите на сообщение (значение) и получателя (метод).

```
class Calculator
  def add(x, y)
    x + y
  end
end

my_calculator = Calculator.new
my_calculator.send(:add, 3, 4)
```
`сообщение send получатель my_calculator`

20) Укажите на сообщения (значения) и получателя (метод).

```
3 + 4
```
`сообщение + получатель 3`

21) Укажите отправителя, получателя, и само сообщение когда мы дернем метод Circle#area.

```
class Circle
  def area(radius)
    calc = Calculator.new
    calc.pi * radius ** 2
  end
end

class Calculator
  def pi
    3.14
  end
end

my_circle = Circle.new
p my_circle.area(3)
```
`Получатель Circle, сообщение new;
получатель my_circle, сообщение area;
отправитель my_circle, получатель Calculator, сообщение new;
отправитель my_circle, получатель calc, сообщение pi;`
